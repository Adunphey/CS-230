# CS-230
 The Gaming Room

 About the Client
 My client was The Gaming Room, and they needed a software solution for their game Draw It or Lose It that could be expanded and was safe.  The client needed support for sessions with more than one person, unique names for all game characters, and the ability to grow across multiple platforms while keeping security and efficiency high.

 What I did right
 I did especially well turning the client's needs into clear suggestions for architecture and design.  I linked technical choices, like using the Singleton and Iterator design patterns, to the needs for uniqueness and scaling.  Additionally, I made a strong case for picking Linux-based computers because they are safe, stable, and inexpensive.

 Process That Helps
 Reading the design paper helped me because it made me think about problems that might come up during development before I started writing code.  I got a better sense of the project as a whole after making the UML model, listing the constraints, and looking at the operating systems.  It was easy to understand how the different parts of the system would work together, and early warnings of possible risks were given.

 Changes I Would Make
 If I could change one thing about the work, I would make the comparison between operating systems more in-depth.  Even though I said Linux was the best option, the paper could use more information about the pros and cons of Windows and Mac, especially when it comes to developer skills and costs.

 Figuring out what users want
 I saw what the user wanted by focusing on protection, scalability, and not being tied to any one platform.  Since the client wanted to reach people on both desktop computers and mobile phones, I stressed cross-platform compatibility with Flutter for phones and JavaFX for desktop computers.  It is important to think about what the users want because the game's success rests on making sure that all devices offer a smooth experience.

 How to Go About Making Software
 Modular, object-oriented design and tried-and-true design patterns were at the heart of my method.  I also used best practices that are common in the industry, like secure communication, managing dependencies, and containerized distribution.  I would add to this in the future by getting more feedback from stakeholders early on in the design process and using iterative design reviews to make sure the answer keeps meeting changing client needs.
